---
layout: post
title: 'CMake: custom_target and custom_command'
---


What I wanted to achieve: in CMT we had "apply_pattern" to call a "pattern", i.e., in my case, a set of repetitive commands to generate boilerplate code

In CMake I struggled to find a solution. I experimented with many patterns before finding the solution.

In our package CMakeLists.txt file, we can us "add_custom_command()" to define a custom command to run  script to generate the boilerplate code. It has an OUTPUT option to define the output files generated by the command. Then we can trigger the command by using an "add_custom_target()" call, where we use the output files of the custom command as dependencies of the custom targets, by using the declaration "DEPENDS <output files>".
In the end, we can set a dependency of our main package target on the custom target, with the usage of "add_dependency()".
In that way everything works fine. During the compilation, the custom target is called before the main target, triggering the custom command which generate the boilerplate code needed in the compilation of the main package target.

But... what if we would like to define a common custom command, one for all packages which need customized boilerplate code? The package do not need the same boilerplate code: they need a customized version of the boilerplate code; but the code defining the command to generate it is the same for all of them. So it is a nice idea having it defined somewhere in a common package, then use it from all packages needing the customized boilerplate code.

But if we use the "add_custom_target()" approach, the above pattern does not work. Because the custom target is built only once, and then the boilerplate-generating custom command is called only for the first package using it...

So, I had to find out a different mechanism.

